<!DOCTYPE html>
<html>
<body>
  <button id="record">Start Recording</button>
  <button id="save" disabled>Save MP3</button>
  <div id="status">Ready</div>
  
  <script>
    const fs = require('fs');
    const path = require('path');
    const { exec } = require('child_process');
    
    let mediaRecorder;
    let audioChunks = [];
    let audioContext;
    let isRecording = false;
    
    // Get buttons
    const recordBtn = document.getElementById('record');
    const saveBtn = document.getElementById('save');
    const status = document.getElementById('status');
    
    // Start/Stop recording
    recordBtn.onclick = async () => {
      try {
        if (!isRecording) {
          // Start recording
          console.log('Requesting microphone access...');
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          console.log('Microphone access granted');
          
          audioContext = new AudioContext({ sampleRate: 44100 });
          console.log('AudioContext created');
          
          mediaRecorder = new MediaRecorder(stream);
          audioChunks = [];
          
          mediaRecorder.ondataavailable = e => {
            console.log('Data available:', e.data.size, 'bytes');
            audioChunks.push(e.data);
          };
          
          mediaRecorder.onstop = () => {
            console.log('Recording stopped, total chunks:', audioChunks.length);
            saveBtn.disabled = false;
            status.textContent = 'Recording saved - click Save MP3';
          };
          
          mediaRecorder.onerror = (e) => {
            console.error('MediaRecorder error:', e);
            status.textContent = 'Recording error: ' + e.error;
          };
          
          mediaRecorder.start();
          isRecording = true;
          recordBtn.textContent = 'Stop Recording';
          status.textContent = 'Recording...';
          console.log('Recording started');
        } else {
          // Stop recording
          console.log('Stopping recording...');
          mediaRecorder.stop();
          mediaRecorder.stream.getTracks().forEach(track => track.stop());
          isRecording = false;
          recordBtn.textContent = 'Start Recording';
        }
      } catch (error) {
        console.error('Error:', error);
        status.textContent = 'Error: ' + error.message;
      }
    };
    
    // Save as MP3 file (using WAV + FFmpeg conversion)
    saveBtn.onclick = async () => {
      try {
        status.textContent = 'Saving audio...';
        console.log('Starting save process...');
        console.log('Audio chunks:', audioChunks.length);
        
        const audioBlob = new Blob(audioChunks);
        console.log('Blob size:', audioBlob.size, 'bytes');
        
        const arrayBuffer = await audioBlob.arrayBuffer();
        console.log('ArrayBuffer size:', arrayBuffer.byteLength);
        
        // Decode audio to raw PCM
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        console.log('Audio decoded:', audioBuffer.duration, 'seconds');
        
        // Convert to WAV first
        const wavBuffer = audioBufferToWav(audioBuffer);
        console.log('WAV buffer size:', wavBuffer.byteLength, 'bytes');
        
        // Save as temporary WAV file
        const timestamp = Date.now();
        const tempWavPath = path.join(__dirname, `temp-${timestamp}.wav`);
        const mp3Path = path.join(__dirname, `recording-${timestamp}.mp3`);
        
        fs.writeFileSync(tempWavPath, Buffer.from(wavBuffer));
        console.log('Temp WAV saved:', tempWavPath);
        
        // Try to convert using FFmpeg if available
        status.textContent = 'Converting to MP3...';
        
        // Check if ffmpeg is available
        exec('ffmpeg -version', (error) => {
          if (error) {
            // FFmpeg not available, save as WAV instead
            console.log('FFmpeg not found, saving as WAV instead');
            const wavFinalPath = path.join(__dirname, `recording-${timestamp}.wav`);
            fs.renameSync(tempWavPath, wavFinalPath);
            status.textContent = `Saved as WAV: ${wavFinalPath}`;
            saveBtn.disabled = true;
          } else {
            // Convert to MP3 using FFmpeg
            const ffmpegCommand = `ffmpeg -i "${tempWavPath}" -codec:a libmp3lame -b:a 128k "${mp3Path}"`;
            console.log('Running FFmpeg:', ffmpegCommand);
            
            exec(ffmpegCommand, (error, stdout, stderr) => {
              // Delete temp WAV file
              try {
                fs.unlinkSync(tempWavPath);
              } catch (e) {
                console.log('Could not delete temp file:', e);
              }
              
              if (error) {
                console.error('FFmpeg error:', error);
                status.textContent = 'Conversion failed, file saved as WAV';
              } else {
                console.log('MP3 created successfully');
                status.textContent = `Saved: ${mp3Path}`;
              }
              saveBtn.disabled = true;
            });
          }
        });
        
      } catch (error) {
        console.error('Save error:', error);
        status.textContent = 'Save error: ' + error.message;
      }
    };
    
    // Convert AudioBuffer to WAV format
    function audioBufferToWav(audioBuffer) {
      const numChannels = audioBuffer.numberOfChannels;
      const sampleRate = audioBuffer.sampleRate;
      const format = 1; // PCM
      const bitDepth = 16;
      
      // Interleave channels
      const length = audioBuffer.length * numChannels;
      const result = new Int16Array(length);
      
      const channelData = [];
      for (let i = 0; i < numChannels; i++) {
        channelData.push(audioBuffer.getChannelData(i));
      }
      
      let offset = 0;
      for (let i = 0; i < audioBuffer.length; i++) {
        for (let ch = 0; ch < numChannels; ch++) {
          const sample = Math.max(-1, Math.min(1, channelData[ch][i]));
          result[offset++] = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
        }
      }
      
      // Create WAV file buffer
      const buffer = new ArrayBuffer(44 + result.length * 2);
      const view = new DataView(buffer);
      
      // WAV header
      writeString(view, 0, 'RIFF');
      view.setUint32(4, 36 + result.length * 2, true);
      writeString(view, 8, 'WAVE');
      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, format, true);
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * numChannels * bitDepth / 8, true);
      view.setUint16(32, numChannels * bitDepth / 8, true);
      view.setUint16(34, bitDepth, true);
      writeString(view, 36, 'data');
      view.setUint32(40, result.length * 2, true);
      
      // Write PCM samples
      let writeOffset = 44;
      for (let i = 0; i < result.length; i++) {
        view.setInt16(writeOffset, result[i], true);
        writeOffset += 2;
      }
      
      return buffer;
    }
    
    function writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }
  </script>
</body>
</html>